#+TITLE:     Emacs Configuration File
#+AUTHOR:    Patrick Michael Niedzielski
#+EMAIL:     patrick@pniedzielski.net

* Org-mode Emacs Configuration
  This org-mode file contains [[https://pniedzielski.net/][Patrick M. Niedzielski]]’s Emacs
  configuration, written in a [[https://en.wikipedia.org/wiki/Literate_programming][Literate Programming]] style.  The
  configuration targets GNU Emacs git-master and, although
  cross-platform, does not support any other version of GNU Emacs or
  any other Emacs editor (such as XEmacs).

  This document is the result of declaring [[https://www.emacswiki.org/emacs/DotEmacsBankruptcy][=.emacs= bankruptcy]]
  during 2016.  At the time, my Emacs configuration was too large and
  unwieldy to maintain.  It had become difficult to do anything but
  add more configuration to the end of the file; any modifications to
  existing configuration ran a very high risk of breaking the entire
  configuration file.  The result was a long time lost to debugging my
  text editor, which could have been more productively used on my own
  projects.  When this became too unbearable, I started anew.

  To make sure that I wouldn’t have to do this again, I decided on two
  major pillars of my configuration file.  First, and in fact
  primarily, I would write it in a Literate Programming style.  A big
  part of the problem in my prior configuration was not knowing the
  thought process that went into old configurations.  Towards the end
  of my old configuration file’s life, some of this was solved by good
  git commit messages, but there was enough cruft that make this not a
  good solution.  Literate Programming allows me to write prose to
  describe my intention with a particular piece of configuration, and
  to link together different parts of configuration that need to be
  separate in Emacs Lisp, but which make sense together in my prose.
  Second, I would use John Wiegley’s [[https://github.com/jwiegley/use-package][use-package]] macro, which would
  make each piece of the configuration code itself declarative.  This
  would free me from the minutiae of [[info:elisp#Autoload][Emacs’s autoload functionality]]
  and such.

  Through the years, my primary use of Emacs has shifted.  In 2016, I
  was primarily writing C++ and Perl code.  Now, though, I use Emacs
  for reading and writing academic works, and the little code I do
  write is in Haskell.  I have also needed to use this configuration
  file different Debian machines (usually my personal machines) and
  Windows boxes (usually work machines).  Furthermore, as I’ve learned
  more Emacs, the way I have used it has changed dramatically.  I
  think it’s a testament to the above two decisions that my
  configuration is still easy to use and maintain, despite the quite
  major shifts in what it’s been intended to do.

  Until 2021, my configuration was private, so I did not need to worry
  about whether to keep secrets like passwords in the file or not.
  Now, I am migrating the configuration to a public git repository, so
  others can see what sorts of things I have in my configuration.  I
  have needed to do this carefully, so in the meantime this repository
  may not have everything that my active configuration has.  The
  ultimate goal is to migrate entirely over to this configuration.

** License
   Copyright © 2016-2021, Patrick M. Niedzielski.

   The following license applies both to this Org file and to the
   corresponding Emacs configuration file that can be generated from
   this file (as well as any other derivative works).

   #+name: license
   #+begin_src emacs-lisp :tangle no
     ;; This program is free software: you can redistribute it and/or
     ;; modify it under the terms of the GNU General Public License as
     ;; published by the Free Software Foundation, either version 3 of the
     ;; License, or (at your option) any later version.
     ;;
     ;; This program is distributed in the hope that it will be useful, but
     ;; WITHOUT ANY WARRANTY; without even the implied warranty of
     ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     ;; General Public License for more details.
     ;;
     ;; You should have received a copy of the GNU General Public License
     ;; along with this program.  If not, see
     ;; <http://www.gnu.org/licenses/>.
   #+end_src

** How This Works
   This Emacs configuration is based on [[http://orgmode.org/worg/org-contrib/babel/intro.][Org Babel]], which allows source
   code blocks to live inside an org-mode document; the org-mode
   document can then be *woven* into an output document format (such
   as HTML or LaTeX) that describes the source code and *tangled* into
   an output source file (in this case, Emacs Lisp) that can be run.
   Our actual =init.el= file is a simple stub that tangles this
   org-mode file and then executes it.

   The tangled file should have the license text and a note reminding
   us to modify the org-mode file instead of the tangled source file.

   #+begin_src emacs-lisp :noweb yes   :comments no
     ;;; configuration.el --- Emacs configuration file

     ;; This source file has been generated from an org-mode file.
     ;; Modifications should be performed on the org-mode file!

     <<license>>


   #+end_src

** Tangle this file
   Although load times don’t matter too much for us, since we use an
   Emacs daemon, we can still save a bit of time on startup by
   compiling the elisp we produce.  One way to do this is to tangle
   and compile this org file every time we save it.  We’ll have to be
   careful, because if ever the =.elc= file and the =.org= file get
   out of sync, we’ll have some hard-to-track-down bugs.

   In order to tangle and compile the org file every time we save it,
   we define a hook that runs every time a file is saved.  If the file
   is our configuration org file, we tangle it and compile it.  In our
   =init.el= file, we load the =.elc= file if it exists, and otherwise
   we tangle and load the =.org= file.

   #+begin_src emacs-lisp
     (defun pmn/tangle-dotfiles ()
       "If the current file is this file, the code blocks are tangled."
       (letrec ((org-file (expand-file-name "configuration.org" user-emacs-directory))
                (el-file  (concat (file-name-sans-extension org-file) ".el")))
         (when (equal (buffer-file-name) org-file)
           (org-babel-tangle nil el-file)
           (byte-compile-file el-file))))

     (add-hook 'after-save-hook #'pmn/tangle-dotfiles)
   #+end_src

* Package Installation and Dependencies
  In this section, we set up the backbone of our configuration:
  Emacs’s built-in =package.el=, and the =use-package= macro.

** =package.el= Configuration
   Most of our packages we install using =package.el=, which is
   bundled with Emacs 24 and later.  There are three major package
   repositories for Emacs packages; we use the first two listed here.

   * ELPA      :: The repository for GNU-sanctioned packages.
   * MELPA     :: Contains the largest selection of pcakages and is
                  built directly from source in the package’s VCS.
   * Marmalade :: Packages are uploaded by users and so tend to be at
                  stable (albeit old versions)

   We do not use Marmalade because it often has the same packages as
   MELPA, only with older versions.  This can sometimes lead to
   conflicts that we want to avoid.  So, we can set up the two package
   repositories we plan to use.

   #+begin_src emacs-lisp
     (require 'package)
     (setq package-archives '(("gnu"   . "http://elpa.gnu.org/packages/")
                              ("melpa" . "https://melpa.org/packages/")))
   #+end_src

   At some point, I’m going to want to look into the new non-GNU ELPA
   repository, which has some nice packages as well, although they are
   frequently in MELPA as well.

   It’s very useful to keep all our installed packages in a single
   place, separate from any local Lisp code we have.  This gives us
   the option of deleting the installed packages whenever we want to
   reset our Emacs state, and keeps our Emacs configuration directory
   tidy.  Let’s put them in the =elpa= directory under our Emacs
   configuration directory.

   #+begin_src emacs-lisp
     (setq package-user-dir (concat user-emacs-directory "elpa"))
   #+end_src

   It’s important for our configuration that packages are not
   initialized until we have set up all the =use-package= invocations
   that declare what packages we want to use.  To do this, we tell
   =package.el= not to activate any packages early on.

   #+begin_src emacs-lisp
     (setq package-enable-at-sstartup nil)
   #+end_src

   Finally, we start up =package.el=.

   #+begin_src emacs-lisp
     (package-initialize)
   #+end_src

** =use-package= Configuration
   Now that =package.el= is set up and ready to use, we’re ready to
   configure =use-package=, which we use to automatically install the
   packages we want and to track dependencies between them.
   =use-package= provides us with a macro that centralizes all the
   configuration for each package, and lets us state the conditions
   under which we can load the package.

   Before using =use-package=, though, we need to make sure it’s
   installed, or install it if it’s not already!  We need to bootstrap
   by using =package.el= to fetch and install =use-package= if it’s
   not locally installed.  While we’re at it, we pick up the package
   =diminish=, which lets us control what packages are shown in the
   modeline, and =bind-key=, which lets us bind keys more easily.
   Both of these are integrated nicely into =use-package=.

   #+begin_src emacs-lisp   :noweb yes   :comments no
     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package)
       (package-install 'diminish))
     
     <<use-package-config>>
     
     (require 'use-package)
     (require 'use-package-ensure)
     (require 'diminish)
     (require 'bind-key)
   #+end_src

   Because we can’t use =use-package= itself to configure
   =use-package=, we’ll have a handful of loose configured options set
   up here at the start.  We chose to be a bit more verbose in what we
   output, so that we can keep track of what is going on in the
   systemd journal.  We also make sure download packages by default if
   they aren’t already installed (known in =use-package=-speak as
   /ensuring/).

   #+name: use-package-config
   #+begin_src emacs-lisp   :tangle no
     (setq use-package-verbose            t
           use-package-expand-minimally   nil
           use-package-compute-statistics t
           use-package-always-ensure      t)
   #+end_src

   Finally, to avoid unnecessary garbage collection during start up,
   we’ll raise the (rather low) garbage collection and process
   buffering thresholds.  ([2021-09-07 mar]: This seems out of place
   here, and I didn’t document why I chose this location in the
   configuration to put these two statements.  It might make sense to
   break it out later, or at least move it somewhere else.)

   #+begin_src emacs-lisp
     (setq gc-cons-threshold (* 50 1000 1000))
     (setq read-process-output-max (* 1024 1024)) ; 1mb
   #+end_src

** Emacs Server
   I usually run Emacs as a server on my systems, with emacsclients
   connecting to the server.  Let’s make sure to enable this
   functionality.

   #+begin_src emacs-lisp
     (require 'server)
   #+end_src

** exec-path-from-shell
   Finally, I have [[https://github.com/pniedzielski/dotfiles-ng][a lot of modifications to my =PATH= variable and
   others]] that I want to import into Emacs, regardless of whether it
   was started with systemd or not.  To do this, we can use the
   =exec-path-from-shell= package, and only initialize it when Emacs
   is started as a daemon (non-interactively, so not from a shell).

   #+begin_src emacs-lisp
     (use-package exec-path-from-shell
        :config (when (daemonp)
                  (exec-path-from-shell-initialize)))
   #+end_src

* Movement
  The benefits in movement that Emacs gives are probably its killer
  feature as a text editor for me.  While some people really customize
  their editor a lot for keybindings and replacing functionality, I
  try to use stock keybindings and built-in packages as much as
  possible.  That said, each configuration I have here is one that
  made my life significantly better than before, so I don’t feel bad
  about moving away from the stock functionality here.

** Keybindings
   There’s some basic movement functionality that I use quite
   frequently when I’m writing documents: moving by paragraph and
   moving by page.  Because my keyboard has a hyper key, let’s bind
   more convenient movement keys to them:

   #+begin_src emacs-lisp
     (use-package lisp
       :ensure nil
       :bind (("H-f" . forward-paragraph)
              ("H-b" . backward-paragraph)
              ("C-H-f" . forward-page)
              ("C-H-b" . backward-page)))
   #+end_src

* Writing
  I spend most of my time in Emacs nowadays reading and writing prose,
  so the most important configurations in this document relate to
  reading and writing.

  The sections that follow are mostly centered around ~text-mode~ and
  modes that derive from it.

** Text
   ~text-mode~ is probably my most-used major mode, directly and via
   its derivative modes.

   One of the most useful aspects of ~text-mode~ is its understanding
   of prose structure.  The following keybindings (cognate with the
   line movement keybindings) skip around the buffer on a
   sentence-by-sentence basis:

   * ~M-a~ (~backward-sentence~)
   * ~M-e~ (~forward-sentence~)
   * ~M-k~ (~kill-sentence~)
   * ~C-x <DEL>~ (~backward-kill-sentence~)

   See [[info:emacs#Sentences][the *Sentences* section of the Emacs manual]] for more
   information.

   By default, though, these commands determine sentence boundaries
   using punctuation followed by two spaces.  In fact, this is how I
   type myself, so this default works well for prose I write.  I seem
   to be in the minority, though, and whenever I’m working with text
   written by someone else, it gets very annoying when the sentence
   commands don’t see any sentence boundaries.  This is worse than the
   alternative, where too many false positives are given for possible
   sentences.  We could tell Emacs to need only a single space for
   separating sentences, as below:

   #+begin_src emacs-lisp   :tangle no
     (add-hook 'text-mode-hook
               (lambda () (setq sentence-end-double-space nil)))
   #+end_src

   However, there is a problem with this: it deletes the double spaces
   in my own documents when I reflow paragraphs.  Yuck.  For the
   moment, I don’t have a good solution to this.  I think I’d rather
   get annoyed when working with the anemic text documents that lack
   double spacing, more than have Emacs muck up my own documents.
   Maybe someday, I’ll write a bit of code to automatically detect
   whether to set ~sentence-end-double-space~ on a buffer-by-buffer
   basis, à la [[http://mbork.pl/2014-10-28_Single_vs_double_spaces][this solution by Marcin Borkowski]].  I like the DWIMness
   of it, but there are enough open threads to this solution that,
   again, I think I would find it more annoying than helpful.

** Spell Checking
   I am terrible at spelling—much more terrible than a recovering
   Indo-Europeanist should be.  Flyspell marks my spelling errors
   on-the-fly, underlining in red words that aren’t in my system’s
   English dictionary.  This does yield a significant number of false
   positives, but it’s good enough to catch most of my spelling
   mistakes.

   We turn on flyspell in modes that are derived from ~text-mode~, and
   we turn on flyspell only in comments for modes that are derived
   from ~prog-mode~.

   #+begin_src emacs-lisp
     (use-package flyspell
       :diminish flyspell
       :hook ((text-mode . flyspell-mode)
              (prog-mode . flyspell-prog-mode)))
   #+end_src

   My systems tend to have Esperanto as their default language (for
   displaying the interface), but most of the text I write is in
   English (obviously).  The ~auto-dictionary~ package detects which
   language the text I’m writing is in and sets the spell-check
   dictionary to that language.  We’ll turn this on whenever we have
   flyspell on.

   #+begin_src emacs-lisp
     (use-package auto-dictionary
       :after flyspell
       :hook (flyspell-mode . auto-dictionary-mode))
   #+end_src

   Once flyspell detects a spelling error, we have two options to fix
   it.  First, we can use the built-in command ~ispell~, which works
   on the whole buffer.  I use this pretty frequently.  Alternatively,
   the ~flyspell-correct~ and ~flyspell-correct-ivy~ packages allow us
   to correct a spelling at the point, giving us a nice ivy-based
   completion interface for selecting the correct replacement.

   #+begin_src emacs-lisp
     (use-package flyspell-correct
       :after flyspell
       :bind (:map flyspell-mode-map
              ("C-;" . flyspell-correct-wrapper)))

     (use-package flyspell-correct-ivy
       :after flyspell ivy flyspell-correct)
   #+end_src

* Completion
** Ivy
   Although I used Ido for quite a long time, I made the switch to [[https://oremacs.com/swiper/][Ivy]]
   a little while ago.  While it’s more heavyweight than Ido, it’s not
   too heavy and provides a lot more nice features and integration
   wit  h other packages.  We’ll make sure it’s installed, then turn it
   on globally.

   #+begin_src emacs-lisp
     (use-package ivy :demand
       :diminish ivy-mode
       :config
       (setq ivy-use-virtual-buffers t
             ivy-count-format "%d/%d ")
       (ivy-mode 1))
   #+end_src

   The Counsel package builds on Ivy, to provide more intelligent and
   more useful completion in a lot of common cases.

   #+begin_src emacs-lisp
     (use-package counsel :demand
       :after ivy
       :diminish counsel-mode
       :config (counsel-mode))
   #+end_src

   The third of the Ivy trio is Swiper, which is halfway between
   Emacs’s search functionality and its ~occur~ functionality.  While
   some people swear by using it for search, I use Emacs incremental
   search primarily as a movement command, so that’s not for me.
   Instead, I use Swiper more like ~occur~, allowing me to see all
   results and jump between them efficiently.  I bind this to a
   keybinding under the ~M-s~ search hierarchy, parallel to ~occur~﻿’s.

   #+begin_src emacs-lisp
     (use-package swiper
       :after ivy
       :bind ("M-s s" . swiper ))
   #+end_src

   One of the nice thing about Ivy is the number of packages that
   integrate with it in various ways.  One nice-to-have package,
   although by no means necessary, is the ~ivy-rich~ package, which
   gives more information in the minibuffer for each completion
   option.

   #+begin_src emacs-lisp
     (use-package ivy-rich
       :config (ivy-rich-mode 1))
   #+end_src

   I also have found that I like ~ivy-hydra~, which pops up a buffer
   listing all the operations I can perform on a search result.

   #+begin_src emacs-lisp
     (use-package ivy-hydra
       :after ivy)
   #+end_src

** Amx
   From the [[https://github.com/DarwinAwardWinner/amx/][Amx website]],

   #+begin_quote
   Amx is an alternative interface for ~M-x~ in Emacs.  IT provides
   several enhancements over the ordinary ~execute-extended-command~,
   such as prioritizing your most-used commands in the completion list
   and showing keyboard shortcuts, and it supports several completion
   systems for selecting commands, such as ido and ivy.
   #+end_quote

   Amx is a fork of [[https://github.com/nonsequitur/smex][Smex]], which no longer appears to be maintained
   (the last commit was on [2015-12-12 sab]).

   #+begin_src emacs-lisp
     (use-package amx
       :after ivy
       :config (amx-mode 1))
   #+end_src
